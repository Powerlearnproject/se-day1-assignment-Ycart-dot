[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15570137&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software Engineering is the systematic application of engineering principles in development, maintenance and testing(nope its not just about writing code) to develop a high quality software which meets all customer requirements. There are many practices needed for producing quality software efficiently and reliably.

Tech Industry Role

1. Software engineering practices help in guaranteeing that the software is consistent, functional and has user expectations. This is the case for any class of everyday consumer software and applications that serve critical needs such as in health or financial services.

2. Efficiency: systematic software engineering methods of realizes faster development processes. This also decreases time-to-market and minimizes resource waste.

3. Scalability and Maintainability: Good software engineering creates scalable and maintainable code. Many software systems tend to grow and change over time.

4. Curbing Cost: A good software engineering ensures that cost can be controlled at the development stage, which leads to a decrease in cases of patches or updates occurring after release.

5.Risk Management: It forces you to identify and mitigate the risks at an early stage, well before the software goes for a release due its stringent testing levels & quality control processes.



Identify and describe at least three key milestones in the evolution of software engineering.

1. Structured Programming (1960s-1970s):Pioneered by Edsger Dijkstra, it promoted dividing programs into sections with one entry and exit point that formed a horizontal linear sequence for increased readability and maintainability.

2. Waterfall Model (1970): Suggested by Winston W. Royce: Consists of a linear and sequential methodology with which you have to complete each phase before the next one starts(R&D, Desing Implementation Testing Deployment Maintenance) It provides a structured framework but is very rigid;

3. Agile Methodologies (1990s-2000s): Such as Scrum, and Extreme Programming Introduces Iterative Development &incremental development, focusing on flexibility, continuous feedback, and collaboration, transforming software development by allowing faster and more adaptive delivery.

List and briefly explain the phases of the Software Development Life Cycle.

﻿Some stages of the Software Development Life Cycle (SDLC) are:

1. Planning:Presents the goals and the stakeholders of the assignment and determines the beginning and the end of the undertaking with appreciable research to illustrate the feasibility of the assignment. Result: a micro plan of the general project, still a long term plan.

2. Requirements Gathering and Analysis: State and reap the stakeholder’s want in addition to the device requirement. Result:It includes a requirements specification document.

3. Design:Builds a logical map of a massive and complicated structure based totally on the requirements: an illustration of the architecture of the device; an example of what data fashions and interfaces seem like. Result: Design files.

4. Implementation (or Coding):This also includes formula of applications based to architectural and structural body paintings that has been supplied. Result: The software code.

5. Testing: debugs, this is, examines and rectifies faults the usage of several techniques of checking out to make sure the software program functioning as anticipated. Rwsult :The tangible, real, or real-life product that has been created, attempted and generated for its utility.

6. Deployment:Deploys this system as a consumable tool for the audience, and also, take a look at on its fame inside the manufacturing realm. Result: Application software in the clients domain.

7. Maintenance: This includes modification physical games together with correction of errors achieved on the software program and addition of features that would enhance effectiveness of the software. Result: Performed constantly on enhancement sports and facilitation.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The Waterfall Methodology is a linear or concept N-stage model in software development whereby each stage include REQ, DES, COD/IMPL,, test then Release & Maintenance phases and so that you can only move on to the next stage until all stages are complete. It includes documentation, and it adheres to a meaningful paradigm that happens in an orderly fashion(milliseconds -> seconds). But the disadvantage of waterfall model is, it is not flexible and testing comes at later stages which means more effort to find problems takes more time prolonged in identifying issues so also long lead times. It suited best where requirement can not be changed too quickly such as safety or a regulatory requirements based project.

Whereas Agile Methodology revolves around the principle of Iterative development with feedback and continuous (incremental) delivery. This made it easier to have a smooth flow of professional communication between different professionals and clients. This development model is in contrast with the more free-form approach of Agile which is especially useful for poorly understood and quickly changing projects, when a product doesn´t need to be brought all at once. While it could possibly be not as clear-cut in terms of how you should accomplish this or maybe just a little bit the amount that process need and cost, to an extent less documentation This is excellent when there is severe ambiguity on what the requirements are or how they will change over time, plus you have high turnover in getting actual software development done.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

﻿Software Developers focus on coding, implementing featuress, and making sure that the software program functions as supposed.
Quality Assurance Engineers are accountable for trying out and making sure the software program meets exceptional requirements before launch.
Project Managers oversee the overall undertaking execution, coping with timelines, assets, and communication to ensure a successful project delivery.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

IDEs automates the software development process by providing a single environment to code and execute (debug) your application means productivity increases in coordination. With VCS, you can manage source code changes and support teamwork as well as create backup & restore strategies for safe development practices. This is mainly in the form of industry standard tools (e.g. Visual Studio, Git) etc
What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Common complications and procedures:

1. Meet complex requirements:
   - Difficulty: The product requirements of the program may be vague, incomplete or often excessive, something that makes it difficult to meet user expectations.
   - Methods: Use requirements management techniques such as posting detailed documentation, regular stakeholder engagement and strategic actions to implement changes in the. Use clear communication channels and maintain traceable requirements matrix.

2. Technical costs used:
   - Difficulty: Accumulation of Å technology costs from quick solutions or poor quality solutions can lead to challenges of high maintenance and upgrade costs in the long run.
   - Methods:Refactors permanent rules, implements rule changes and prioritizes technical cost management during the development process. Allowing time for processing is important along with business development to ensure long-term quality of the code.

3. Make sure system features are good:
   - Challenge: It can be challenging to ensure software meets quality standards, including delivery, security and accessibility.
   - Methods: Implements a comprehensive testing framework including unit, integration, system and acceptance testing. Use automated testing tools, continuous integration and continuous classification (CI/CD) practices to ensure quality throughout the development lifecycle.

4. Dealing with changing technology:
   - Challenge:Rapid advances in technology and applications can make it difficult for engineers to stay up-to-date and make informed decisions.
   - Strategy: Invest in continuous improvement and professional development. Encourage participation in technical resources, attend industry events and promote a culture of ongoing learning within the team.

  

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing: As the name suggests this is to testing a units/components individually in isolation i.e., early detection of errors/code quality.

Integration testing tests how the components work together and exchange data i.e., test communication between those component logs when they are combined due to whatever causes that.

System Testing: The complete integrated system should be tested for sufficient amount of transactions as that whats required, to guarantee the requirements are met, and authenticated functionality in a functional environment.

The acceptance test is conducted to verify that an application product meets the user's need and standard before it comes for distribution, also ensure usability & performance requirement are met.

At different stages of the testing process -- each serves its own purposes and is necessary as one kind cannot substitute another in revealing issues preventing your system working correctly.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process of designing and redesigning prompts, questions or instructions to interact logically with the AI ​​model for desired outputs. This requires careful feedback that gives the model a very clear idea of ​​what it needs or, conversely, what it is looking for from the AI, which will allow it to interpret and he answers the question correctly

Importance.

1. Improves Accuracy: Unstructured feedback will help the AI ​​model establish the context and context of the request, thus finding the right answer. According to him, explicit presentation will eliminate most of the ambiguity, thereby closing the gap between what the image produces and what the user expects

2. Improves efficiency: Stating the specific requirements or limitations of the presentation can save time in providing necessary information or results rather than asking for follow-up information it is clearly defined.

3. Better results: Effective leading-edge technologies help users harness the full potential of an AI model for creative content creation, complex analysis, or consumption address a specific problem, thus increasing the value of communication.

4. Reduces misunderstanding:A well-designed prompt avoids misinterpretation and enables the AI ​​to provide any relevant and useful information, thus improving the overall user experience . . . .

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague prompt:"Describe data structures".

Improved prompt: "Compare the use of arrays and linked lists and compare differences in memory efficiency, speed of access, and ease of insertion or deletion."

Why the improved prompt is more effective:

1. Clarity:It clearly states the two data structures to be compared (arrays and linked lists) and the objects to be compared: memory efficiency, access speed, and insertion/deletion.
2. Specificity:The direction of the prompt regarding the comparison—making the information more useful and relevant.
3. Conciseness: A concise presentation ensures that the description is directly relevant to the user's need for comparative understanding.

It helps generate detailed, focused responses and direct responses to key concerns and comparisons.
